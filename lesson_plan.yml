- OOP:
  - What?:
    - Its a Paradigm
    - Objects, Attributes & Behaviors

  - Where?:
    - Software Programs / Systems / Applications

  - When?:
    - When analyzing Software (OOAD)
    - When designing Software (OOAD)
    - When writing software (OOP)
    - When Modeling Real-World objects (OOD)
    - When you want to bind Attributes and Behaviors of objects together
    - When you want to achieve Messaging and Communication among objects

  - Why?:
    - Information Hiding
    - Data Access Control (Scoping)
      - Access Control Modifiers / Access Modifiers:
        - Private
        - Protected
        - Public
        - Package
    - Code re-use

  - How?:
    - Encapsulation
    - Inheritance
    - Abstraction
    - Polymorphism
    - Composition

- Relationships in OOP:
  - Is-A Relationships:
    - Inheritance

  - Has A relationships:
    - Composition:
      - Is-Composed-Of
    - Aggregation:
      - Is-An-Aggregate-Of
    - Dependency:
      - Depends-On
    - Association:
      - Is-Associated-With

- The Composition Principle:
  - The perfect Alternative and/or Suppliment to Inheritance for connecting / coupling objects

- GRASP:
  ...
  - Coupling
  - Couhesion

- The Principle of Coupling
- The Principle of Cohesion

- The Problems, The Ideals & The Solutions
  - Problems:
    - High Coupling
    - Low Cohesion

  - Ideals:
    - Low Coupling
    - High Cohesion

  - Solutions:
    - The SOLID Principles
    - Design Patterns
    - Code Refactoring

The SOLID Principles:
  - Principles:
    - S => Single Responsbility Principle (SRP):
      - "A class should have only one reason for change"
      - In other words a class should serve only one responsbility

    - O => Open-Closed Principle (OCP):
      - "A class should be Open for Extension but closed for Modification"

    - L => Liskov's Substitution Principle (LSP):
      - "If T is a Type and S is a Subtype of T, 
        then The objects of T should be replaceable with
        Objects of S"

    - I => Interface Segregation Principle (ISP):
      - "A class should not be forced to depend on an Interface it does not need"

    - D => Dependency Inversion Principle (DIP):
      - "High level modules should not depend on Low level modules,
        instead both should depend on an interface"

  - Ideals (Success Criteria):
    - Single Responsbility
    - Open-Closed
    - Liskov's Substitution

  - Action Points:
    - Interface Segregation (Segregate Interfaces)
    - Dependency Inversion (Invert Dependancies)

Design Patterns:
  - 